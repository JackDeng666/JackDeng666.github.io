<!doctype html>
<html lang="zh-CN" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-undefined" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.2.1">
<title data-rh="true">nodejs 异步 IO | 嘤嘤博客</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://jackdeng666.github.io/img/favicon.png"><meta data-rh="true" name="twitter:image" content="https://jackdeng666.github.io/img/favicon.png"><meta data-rh="true" property="og:url" content="https://jackdeng666.github.io/docs/nodejs/nodejs-asynchronous-io"><meta data-rh="true" property="og:locale" content="zh_CN"><meta data-rh="true" name="docusaurus_locale" content="zh-CN"><meta data-rh="true" name="docsearch:language" content="zh-CN"><meta data-rh="true" name="keywords" content="嘤"><meta data-rh="true" name="keywords" content="blog, javascript, typescript, node, react, vue, web"><meta data-rh="true" name="keywords" content="编程爱好者, Web开发者, ts全栈"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="nodejs 异步 IO | 嘤嘤博客"><meta data-rh="true" name="description" content="为什么说 nodejs 性能好"><meta data-rh="true" property="og:description" content="为什么说 nodejs 性能好"><link data-rh="true" rel="icon" href="/img/favicon.png"><link data-rh="true" rel="canonical" href="https://jackdeng666.github.io/docs/nodejs/nodejs-asynchronous-io"><link data-rh="true" rel="alternate" href="https://jackdeng666.github.io/docs/nodejs/nodejs-asynchronous-io" hreflang="zh-CN"><link data-rh="true" rel="alternate" href="https://jackdeng666.github.io/docs/nodejs/nodejs-asynchronous-io" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="嘤嘤博客 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="嘤嘤博客 Atom Feed"><link rel="stylesheet" href="/assets/css/styles.e10e95ca.css">
<script src="/assets/js/runtime~main.7aa1d65d.js" defer="defer"></script>
<script src="/assets/js/main.b2528170.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_mCJq" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/favicon.png" alt="My Site Logo" class="themedComponent_RMAM themedComponent--light_ITYx"><img src="/img/favicon.png" alt="My Site Logo" class="themedComponent_RMAM themedComponent--dark_IJzh"></div><b class="navbar__title text--truncate">嘤嘤博客</b></a><img src="/img/snow_pixel_loli_4.gif" style="width:47px;height:38px"></div><div class="navbar__items navbar__items--right"><a aria-current="page" class="navbar__item navbar__link navbar__link--active" target="_self" href="/docs/nodejs/">NodeJs学习</a><a class="navbar__item navbar__link" target="_self" href="/docs/ci-cd/">CICD实践</a><a class="navbar__item navbar__link" target="_self" href="/docs/docker/">Docker</a><a class="navbar__item navbar__link" target="_self" href="/docs/ying-chat/">YingChat项目实战</a><a class="navbar__item navbar__link" target="_self" href="/blog">博客</a><div class="toggle_MW0i"><button class="clean-btn toggleButton_yw5v toggleButtonDisabled_BJd7 mimicry-button" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_SFTY"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_ekgs"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_H2mL"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_eExm"><div class="docsWrapper_P4x8"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_ntye" type="button"></button><div class="docRoot_OIaU"><aside class="theme-doc-sidebar-container docSidebarContainer_ixGz"><div class="sidebarViewport_LGbb"><div class="sidebar_mhZE"><nav aria-label="文档侧边栏" class="menu menu_qCLW mimicry-wrap sunken"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/nodejs">nodejs 架构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/docs/nodejs/nodejs-asynchronous-io">nodejs 异步 IO</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/nodejs/nodejs-event-driven">nodejs 事件驱动架构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/nodejs/nodejs-single-threaded">nodejs 单线程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/nodejs/nodejs-global-object">nodejs 全局对象</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/nodejs/global-variable-process">全局变量 process</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/nodejs/core-module-path">核心模块 path</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/nodejs/buffer">Buffer 缓冲区</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/nodejs/fs/fs-intro">核心模块 fs</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/nodejs/stream/stream-intro">核心模块 stream</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/docs/nodejs/net/net-intro">网络模块</a></div></li></ul></nav><button type="button" title="收起侧边栏" aria-label="收起侧边栏" class="button button--secondary button--outline collapseSidebarButton_JQG6"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_Iseg"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div></aside><main class="docMainContainer_e4cu"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_z5aJ"><div class="docItemContainer_c0TR"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Alpn" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_xK9p"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">nodejs 异步 IO</span><meta itemprop="position" content="1"></li></ul></nav><div class="tocCollapsible_GEL6 theme-doc-toc-mobile tocMobile_bxCs"><button type="button" class="clean-btn tocCollapsibleButton_S0tq">本页总览</button></div><div class="theme-doc-markdown markdown mimicry-wrap"><header><h1>nodejs 异步 IO</h1></header><h3 class="anchor anchorWithStickyNavbar_JvJb" id="为什么说-nodejs-性能好">为什么说 nodejs 性能好<a href="#为什么说-nodejs-性能好" class="hash-link" aria-label="为什么说 nodejs 性能好的直接链接" title="为什么说 nodejs 性能好的直接链接">​</a></h3>
<p>我们都知道 nodejs 在诞生之初是为了实现高性能的 web 服务器，后来经历了长时间的发展之后，nodejs 也就慢慢的演化 成了可用的服务端“语言”，那这样也就让我们 javascript 实现了在浏览器之外的平台去进行工作的场景。</p>
<p>我们就来分析一下，为什么在众多的实现方案当中，而 nodejs 是最出彩的那一个，当然这里也强调一下，此处我使用了一个并不严谨的说法，我把 nodejs 叫做语言，但前提呢是我们都明白它是一个平台，或者说运行时，只是对于前端来说，我们可以直接去使用 js 在 node 环境下去进行编程，而为了后续的内容描述方便，我这里就此约定不再纠结了。</p>
<p>那下面我们就以 bs 架构为基础来说一下，用户去发送请求到获取数据的整个过程，首先用户去通过客户端向服务端发送请求来获取目标数据，而服务端只需要在接收到请求之后，依据业务逻辑去返回数据即可，对于这个过程当中，我们当前并不会去讨论过多的细节，因为我们现在想要探讨的只是 node 作为服务器使用的时候，会有的一些相关内容，那通过下面的图示，我们就不难发现，在我们忽略掉网络带宽，硬件性能等这样的一些客观条件之后，我们真正去影响用户获取数据速度的，其实呢也就是 io 的时间消耗。</p>
<p><img decoding="async" loading="lazy" src="/assets/images/01-7443c9d2de9da29c533ba0dc22742b1e.png" width="695" height="227" class="img_Zn7t"></p>
<p>而我们也都知道 io 绝对是计算机操作过程中最缓慢的一个环节，访问 ram 这样一个级别设备的 io 时间消耗是为纳秒级别的，而在磁盘和网络中访问数据的时间消耗，它的量级是毫秒级别的，那也就是说数据的读写操作终归是要有时间消耗的，那假设当前是一个串行的模式，那么对于一个服务器来说，如果当前正在处理的请求当中，它包含了一个需要长时间等待的 io 行为，那么后续的任务就不能够去得到及时的响应了，很显然这是很不友好的，而且我们当下在开发过程中去使用到的一些服务器，它也都具备了并发处理事务的能力，那么在并发的实现上，传统的做法或者说其他高级编程语言实现的方式，其实就采用多线程或者说多进程的方式，但是这样的解决思路呢，在某些场景下肯定也是会有一些问题的。</p>
<p>那我们这里就使用餐馆服务的例子来进行说明，如果说我们使用多线程来处理这样的一个并发问题，那他的思路就是当我们有几个人来就餐，那么我们就会去准备几个服务员来完成相应的服务，那在这之后呢，客人就去进行点菜，然后服务员就等待这个点菜的结果，那对应到我们的程序里边，就是当前有几个请求从客户端发送到我们的服务端之后，我们的服务端就会去准备几个进程，或者说几个线程来接收这些请求，那这样的服务对于用户的体验来说，是非常友好的，但问题也会很明显，如果某个时间内同时有很多人来进行就餐，而我们是不可能无限的去增加服务员的数量的，那这样无人响应的问题也就出现了。</p>
<p>而分析点餐的过程之后，我们就可以发现，其实大部分的时间消耗都来自于客人点菜，这样的一个行为的等待过程中，而在这个时候，服务员其实是处于空闲状态的，所以基于这种情况，那也就有了 reactor 这样的一个模式，也被叫做应答者模式，它的核心思想其实就是只保留一个服务员，然后客人自己去进行点餐，而当这个客人点餐行为结束之后，他只需要去呼叫当前的服务员就可以了，那这样的话我们就相当于是使用了单线程，而完成了之前多线程才能实现的事情，并且它是非阻塞的，也就是说每个客人进来之后，我们都会有一个服务员能够去立马的给他一个响应，只不过在他点餐的过程中，我们这个服务员可能正在服务于其他的客人，那使 用这样的操作，也就可以去避免多个线程之间在进行上下文切换的时候，需要去考虑的一些状态保存，时间消耗以及状态锁等这样的一些问题。</p>
<p>而 nodejs 也正是基于了 reactor 模式，然后再结合 js 语言本身它所具备的一些单线程、事件驱动的架构和异步编程这样的一些特性，然后让我们这样的一个单线程是可以远离阻塞，从而通过异步非阻塞的 io 来更好的去使用 cpu 资源，并且去实现高并发请求的处理，那这也是为什么，历史上尝试着将 js 是移植到其他平台的实现方案，其实有很多的，而 nodejs 却是最后最出彩的那一个。</p>
<p>那最后我们还要再说明一点，上述内容当中，我们一直在突出的是 nodejs 在处理 io 时所具备的优点，那这也就意味着在非 io 行为的时候，它其实也会有一些不适用的地方，那比如说我们当前点餐的客人，他如果都不需要去花时间来思考我们要吃什么，而是立即进行点餐，那么这个时候一个服务员显然是不够用的，那这样对应到我们的程序里，也就是所谓的 cpu 密集型，所以对于 nodejs 的使用来说，我们更多的是用它去处理 io 密集型的高并发请求，而并不是大量且复杂的业务逻辑处理，但是这些也并不影响我们将 nodejs 应用于同构开发和前端工程化当中，它仍然是大前端的一个基石。</p>
<h3 class="anchor anchorWithStickyNavbar_JvJb" id="异步-io-的实现">异步 IO 的实现<a href="#异步-io-的实现" class="hash-link" aria-label="异步 IO 的实现的直接链接" title="异步 IO 的实现的直接链接">​</a></h3>
<p>接下来我们来说一说 nodejs 当中的异步 io 实现，我们当前要探讨的实现并非是从代码的层面上进行复现，而是从异步 io 实现的思路上来进行串联。</p>
<p>那下面呢我们就先简单的分析一下，在编码的过程中，我们为什么需要去使用到异  步 io，它能够去给我们带来什么样的好处，那如图所示，假设我们当前呢是有两个 io 任务的，而且我们现在是一个单线程的，那这个时候俩任务单独去执行的时候，分别会耗时 t1 和 t2，如果我们现在采用同步的方式来完成，那么总时间 t 应该是大于 t1 和 t2 的和，这个道理也很简单，因为我们 t2 的执行要等到我们 t1 的结果产出之后才会发生，而如果说我们现在采用的是异步的方式来执行的话，那总时间的消耗肯定是小于 t1 和 t2 的和，或者说它干脆就是 t1 和 t2 当中时间较大的那个值，所以这样看来异步 io 的做法对于程序的执行效率来说呢是有帮助的，因此呢我们是需要它的，而异步 io 也并非是 nodejs 的原创，但是他在 nodejs 中却拥有着广泛的应用。</p>
<p><img decoding="async" loading="lazy" src="/assets/images/02-a9008a4609f213d3f7f1c6b322d5b084.png" width="476" height="339" class="img_Zn7t"></p>
<p>那我们在这里就来先探讨一下 node 中它是如何实现的，不过在这之前，我们针对于 异步 io 相关的一些理论，也先来去做一些说明。</p>
<p>其实对于操作系统来说，io 只有阻塞和非阻塞这样的两种的，那也就是说我们当前是否能够去立即获取到调用之后所返回的结果，就像我们上文所提到的那样，当我们采用了非阻塞的 io 之后，cpu 的时间片就可以被拿出来，然后去处理其他的事物，那这个时候对于性能肯定是有所提升的，但是这种操作也同样存在着一些问题，因为立即返回的并不是我们业务层真正期望得到的实际数据，而仅仅是当前的调用状态，那操作系统为了获取完整的数据，它就会让应用程序去重复的调用 io 操作，从而来确认 io 操作是否是已经完成了，那我们也将这种重复调用操作来判断 io 是否完成的技术去叫做轮询，这里我们也简单的去提一下常见的一些轮询技术，例如 read、select、epoll、kqueue、event ports 等等这些，那其中 event ports 就是 linux 下的，而 kqueue 就是 free bsd 系统下的，虽然轮询技术能够去确定 io 是否完成，然后将获取的 io 完成之后产出的数据再返回回去，但是对于代码而言，它还是同步的效果，因为在轮询的过程中，程序仍然是在等待着 io 的结果，所以我们期望的 io 应该是代码可以直接去发起非阻塞的调用，但是他也无需去通过遍历或者说唤醒的方式来轮询的判断当前的 io 是否结束了，而是可以在调用发起之后，直接去进行下一个任务的处理，然后等待 io 的结果处理完成之后，那么再去通过某种信号或者说回调的方式，将数据再传回给当前的代码进行使用就可以了，那这个时候 node 核心当中的 libuv 库就该出场了，我们可以去把这个 libuv 库去看作是几种不同的异步 io 实现方式的抽象封装层。</p>
<p><img decoding="async" loading="lazy" src="/assets/images/03-4f9233d648a8ceaba9de1bbe416e688c.png" width="1019" height="453" class="img_Zn7t"></p>
<p>例如我们现在从这个图里边可以看到的，在类 unix 系统下的 epoll 接口，windows 下的 iocp，还有 centos 的 event ports 等，那他们会在什么时候起作用，简单的说就是当我们运行了一段 nodejs 编写的代码之后，最终是会走到 libuv 库这个环境里来的，而他就可以去对当前的平台进行判断，然后在依据平台调用相应的异步 io 处理的方法，那在这里我们也强调一下，当前我们要描述的是 nodejs，所以后续的环境前提我们都说的是单线程的，了解了这些操作系统对于 io 的支持之后，我们就来看一下 node 当中具体实现异步 io 的过程，这个时候我们就绕不开 node 环境下的事件循环了，但它并不是我们当前探讨的具体内容，而且事件循环过程中，同样也存在着许多的内容是值得呢单独来进行说明的，因此这里我们就先去从 nodejs 代码执行的周期角度来进行介绍异步 io 的实现。</p>
<p><img decoding="async" loading="lazy" src="/assets/images/04-fc432cbd625a3e87c8cb0d761a269291.png" width="973" height="537" class="img_Zn7t"></p>
<p>如上图所示，首先我们使用 node 或者说 nodemon 这样的一些命令来运行一个 js 脚本，那在这里我们就先去省略掉 v8 的工作，我们认为代码是可以直接去运行的，而我们编写的代码当中如果存在着异步的请求，那 libuv 就会去工作，此时它会对相应的异步请求处理程序去进行管理，我们这里还是以 io 操作为例来进行说明，当前我们要处理的如果是网络 io，则就会去调用相应的操作系统底层的 io 接口来进行处理，那如果说我们代码里面的 io 是一个文件 io，那这个时候就会被放入到我们 nodejs 执行实现的这样一个线程池当中，然后去进行处理，但是不论是哪一种处理方式，最终它都会有一个返回的结果，那这个结果在出来之后就会去通过我们的 event loop，也就是事件循环，再去把它对应的回调函数，或者说处理程序加入到这个具体的事件队列当中，然后就等待着 js 的主线程来进行执行，而这个循环我们再去提一下，它也并非是一直运转不停的，当他发现队列当中完全没有了需要等待执行的任务时，他也就会去退出循环，那当前程序的执行也就算是结束了，而对于 nodejs 来说，它的 异步 io 操作也就算是实现和完成了。</p>
<h3 class="anchor anchorWithStickyNavbar_JvJb" id="异步-io-总结">异步 io 总结<a href="#异步-io-总结" class="hash-link" aria-label="异步 io 总结的直接链接" title="异步 io 总结的直接链接">​</a></h3>
<p>那上面这些内容就包含了 nodejs 的 异步 io 实现的理论过程，那在这里边我们也去做一下总结。</p>
<ul>
<li>IO 是应用程序的瓶颈所在</li>
<li>异步 IO 提高性能无需原地等待结果返回</li>
<li>IO 操作属于操作系统级别，平台都有对应实现</li>
<li>Nodejs 单线程配合事件驱动架构及 libuv 实现了异步 IO</li>
</ul>
<p>第一， io 可以看作是任何应用的瓶颈所在，因为它的处理是肯定要消耗时间的，而这个时间是跟我们的设备或者说客观的条件是有很大关系的。<br>
<!-- -->第二，采用了异步 io 的方式之后，是可以提高性能的，因为我们无需在原地等待某个结构的返回，而可以接着去处理其他的任务，那这样我们 cpu 的利用率就会变高了。<br>
<!-- -->第三， io 操作的本身在当前操作系统级别，其实也都是有对应解决的，而我们的 libnv 库，其实就相当于是对这些方法进行了一个抽象的封装，那做到了一个跨平台的效果。<br>
<!-- -->第四， node 配合的 js 的单线程，以及事件驱动和 libuv 库等这样的一些特点，那  就很好的去实现了异步 io，那这样的话我们就不需要等待着异步操作结果返回，可以继续去往下执行我们的 js 代码，而当异步的事件触发完成之后，就会去通知主线程，然后自然是主线程就会来去执行我们相应的事件回调。</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev mimicry-button hover-active myLink_uxiv" href="/docs/nodejs"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">nodejs 架构</div></a><a class="pagination-nav__link pagination-nav__link--next mimicry-button hover-active myLink_uxiv" href="/docs/nodejs/nodejs-event-driven"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">nodejs 事件驱动架构</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_jeP5 thin-scrollbar mimicry-wrap sunken theme-doc-toc-desktop" style="padding:1em 0"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#为什么说-nodejs-性能好" class="table-of-contents__link toc-highlight">为什么说 nodejs 性能好</a></li><li><a href="#异步-io-的实现" class="table-of-contents__link toc-highlight">异步 IO 的实现</a></li><li><a href="#异步-io-总结" class="table-of-contents__link toc-highlight">异步 io 总结</a></li></ul></div></div></div></div></main></div></div></div></div>
</body>
</html>